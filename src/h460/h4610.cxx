//
// h4610.cxx
//
// Code automatically generated by asnparse.
//

#ifdef P_USE_PRAGMA
#pragma implementation "h4610.h"
#endif

#include <ptlib.h>
#include "h460/h4610.h"

#define new PNEW


#if ! H323_DISABLE_H461



//
// ASSETPDU
//

H461_ASSETPDU::H461_ASSETPDU(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H461_ASSETPDU::CreateObject() const
{
  return new H461_ASSETMessage;
}


H461_ASSETMessage & H461_ASSETPDU::operator[](PINDEX i) const
{
  return (H461_ASSETMessage &)array[i];
}


PObject * H461_ASSETPDU::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ASSETPDU::Class()), PInvalidCast);
#endif
  return new H461_ASSETPDU(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H461_ApplicationIE[]={
      {"associateRequest",0}
     ,{"associateResponse",1}
     ,{"statusRequest",2}
     ,{"statusResponse",3}
     ,{"listRequest",4}
     ,{"listResponse",5}
     ,{"callApplist",6}
     ,{"preInvokeRequest",7}
     ,{"preInvokeResponse",8}
     ,{"invokeRequest",9}
     ,{"invokeResponse",10}
     ,{"invoke",11}
     ,{"invokeStartList",12}
     ,{"invokeNotify",13}
     ,{"stopRequest",14}
     ,{"stopNotify",15}
     ,{"callRelease",16}
};
#endif
//
// ApplicationIE
//

H461_ApplicationIE::H461_ApplicationIE(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 17, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H461_ApplicationIE,17
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationIE::operator H461_AssociateRequest &() const
#else
H461_ApplicationIE::operator H461_AssociateRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_AssociateRequest), PInvalidCast);
#endif
  return *(H461_AssociateRequest *)choice;
}


H461_ApplicationIE::operator const H461_AssociateRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_AssociateRequest), PInvalidCast);
#endif
  return *(H461_AssociateRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationIE::operator H461_AssociateResponse &() const
#else
H461_ApplicationIE::operator H461_AssociateResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_AssociateResponse), PInvalidCast);
#endif
  return *(H461_AssociateResponse *)choice;
}


H461_ApplicationIE::operator const H461_AssociateResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_AssociateResponse), PInvalidCast);
#endif
  return *(H461_AssociateResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationIE::operator H461_ArrayOf_ApplicationStatus &() const
#else
H461_ApplicationIE::operator H461_ArrayOf_ApplicationStatus &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ArrayOf_ApplicationStatus), PInvalidCast);
#endif
  return *(H461_ArrayOf_ApplicationStatus *)choice;
}


H461_ApplicationIE::operator const H461_ArrayOf_ApplicationStatus &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ArrayOf_ApplicationStatus), PInvalidCast);
#endif
  return *(H461_ArrayOf_ApplicationStatus *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationIE::operator H461_ArrayOf_ApplicationAvailable &() const
#else
H461_ApplicationIE::operator H461_ArrayOf_ApplicationAvailable &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ArrayOf_ApplicationAvailable), PInvalidCast);
#endif
  return *(H461_ArrayOf_ApplicationAvailable *)choice;
}


H461_ApplicationIE::operator const H461_ArrayOf_ApplicationAvailable &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ArrayOf_ApplicationAvailable), PInvalidCast);
#endif
  return *(H461_ArrayOf_ApplicationAvailable *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationIE::operator H461_Application &() const
#else
H461_ApplicationIE::operator H461_Application &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_Application), PInvalidCast);
#endif
  return *(H461_Application *)choice;
}


H461_ApplicationIE::operator const H461_Application &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_Application), PInvalidCast);
#endif
  return *(H461_Application *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationIE::operator H461_ApplicationStatus &() const
#else
H461_ApplicationIE::operator H461_ApplicationStatus &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ApplicationStatus), PInvalidCast);
#endif
  return *(H461_ApplicationStatus *)choice;
}


H461_ApplicationIE::operator const H461_ApplicationStatus &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ApplicationStatus), PInvalidCast);
#endif
  return *(H461_ApplicationStatus *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationIE::operator H461_ApplicationInvokeRequest &() const
#else
H461_ApplicationIE::operator H461_ApplicationInvokeRequest &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ApplicationInvokeRequest), PInvalidCast);
#endif
  return *(H461_ApplicationInvokeRequest *)choice;
}


H461_ApplicationIE::operator const H461_ApplicationInvokeRequest &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ApplicationInvokeRequest), PInvalidCast);
#endif
  return *(H461_ApplicationInvokeRequest *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationIE::operator H461_ApplicationInvokeResponse &() const
#else
H461_ApplicationIE::operator H461_ApplicationInvokeResponse &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ApplicationInvokeResponse), PInvalidCast);
#endif
  return *(H461_ApplicationInvokeResponse *)choice;
}


H461_ApplicationIE::operator const H461_ApplicationInvokeResponse &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ApplicationInvokeResponse), PInvalidCast);
#endif
  return *(H461_ApplicationInvokeResponse *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationIE::operator H461_ApplicationInvoke &() const
#else
H461_ApplicationIE::operator H461_ApplicationInvoke &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ApplicationInvoke), PInvalidCast);
#endif
  return *(H461_ApplicationInvoke *)choice;
}


H461_ApplicationIE::operator const H461_ApplicationInvoke &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ApplicationInvoke), PInvalidCast);
#endif
  return *(H461_ApplicationInvoke *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationIE::operator H461_ArrayOf_ApplicationStart &() const
#else
H461_ApplicationIE::operator H461_ArrayOf_ApplicationStart &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ArrayOf_ApplicationStart), PInvalidCast);
#endif
  return *(H461_ArrayOf_ApplicationStart *)choice;
}


H461_ApplicationIE::operator const H461_ArrayOf_ApplicationStart &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ArrayOf_ApplicationStart), PInvalidCast);
#endif
  return *(H461_ArrayOf_ApplicationStart *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationIE::operator H461_ArrayOf_Application &() const
#else
H461_ApplicationIE::operator H461_ArrayOf_Application &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ArrayOf_Application), PInvalidCast);
#endif
  return *(H461_ArrayOf_Application *)choice;
}


H461_ApplicationIE::operator const H461_ArrayOf_Application &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ArrayOf_Application), PInvalidCast);
#endif
  return *(H461_ArrayOf_Application *)choice;
}


PBoolean H461_ApplicationIE::CreateObject()
{
  switch (tag) {
    case e_associateRequest :
      choice = new H461_AssociateRequest();
      return TRUE;
    case e_associateResponse :
      choice = new H461_AssociateResponse();
      return TRUE;
    case e_statusRequest :
    case e_callRelease :
      choice = new PASN_Null();
      return TRUE;
    case e_statusResponse :
    case e_listRequest :
    case e_listResponse :
      choice = new H461_ArrayOf_ApplicationStatus();
      return TRUE;
    case e_callApplist :
      choice = new H461_ArrayOf_ApplicationAvailable();
      return TRUE;
    case e_preInvokeRequest :
      choice = new H461_Application();
      return TRUE;
    case e_preInvokeResponse :
    case e_invokeNotify :
      choice = new H461_ApplicationStatus();
      return TRUE;
    case e_invokeRequest :
      choice = new H461_ApplicationInvokeRequest();
      return TRUE;
    case e_invokeResponse :
      choice = new H461_ApplicationInvokeResponse();
      return TRUE;
    case e_invoke :
      choice = new H461_ApplicationInvoke();
      return TRUE;
    case e_invokeStartList :
      choice = new H461_ArrayOf_ApplicationStart();
      return TRUE;
    case e_stopRequest :
    case e_stopNotify :
      choice = new H461_ArrayOf_Application();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H461_ApplicationIE::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ApplicationIE::Class()), PInvalidCast);
#endif
  return new H461_ApplicationIE(*this);
}


//
// AssociateRequest
//

H461_AssociateRequest::H461_AssociateRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H461_AssociateRequest::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+13) << "timeToLive = " << setprecision(indent) << m_timeToLive << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H461_AssociateRequest::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H461_AssociateRequest), PInvalidCast);
#endif
  const H461_AssociateRequest & other = (const H461_AssociateRequest &)obj;

  Comparison result;

  if ((result = m_timeToLive.Compare(other.m_timeToLive)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H461_AssociateRequest::GetDataLength() const
{
  PINDEX length = 0;
  length += m_timeToLive.GetObjectLength();
  return length;
}


PBoolean H461_AssociateRequest::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_timeToLive.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H461_AssociateRequest::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_timeToLive.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H461_AssociateRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_AssociateRequest::Class()), PInvalidCast);
#endif
  return new H461_AssociateRequest(*this);
}


//
// AssociateResponse
//

H461_AssociateResponse::H461_AssociateResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H461_AssociateResponse::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+17) << "associateToken = " << setprecision(indent) << m_associateToken << '\n';
  strm << setw(indent+13) << "timeToLive = " << setprecision(indent) << m_timeToLive << '\n';
  if (HasOptionalField(e_statusInterval))
    strm << setw(indent+17) << "statusInterval = " << setprecision(indent) << m_statusInterval << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H461_AssociateResponse::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H461_AssociateResponse), PInvalidCast);
#endif
  const H461_AssociateResponse & other = (const H461_AssociateResponse &)obj;

  Comparison result;

  if ((result = m_associateToken.Compare(other.m_associateToken)) != EqualTo)
    return result;
  if ((result = m_timeToLive.Compare(other.m_timeToLive)) != EqualTo)
    return result;
  if ((result = m_statusInterval.Compare(other.m_statusInterval)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H461_AssociateResponse::GetDataLength() const
{
  PINDEX length = 0;
  length += m_associateToken.GetObjectLength();
  length += m_timeToLive.GetObjectLength();
  if (HasOptionalField(e_statusInterval))
    length += m_statusInterval.GetObjectLength();
  return length;
}


PBoolean H461_AssociateResponse::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_associateToken.Decode(strm))
    return FALSE;
  if (!m_timeToLive.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_statusInterval) && !m_statusInterval.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H461_AssociateResponse::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_associateToken.Encode(strm);
  m_timeToLive.Encode(strm);
  if (HasOptionalField(e_statusInterval))
    m_statusInterval.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H461_AssociateResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_AssociateResponse::Class()), PInvalidCast);
#endif
  return new H461_AssociateResponse(*this);
}


//
// ApplicationDisplay
//

H461_ApplicationDisplay::H461_ApplicationDisplay(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, FALSE, 0)
{
  m_display.SetConstraints(PASN_Object::FixedConstraint, 1, 128);
}


#ifndef PASN_NOPRINTON
void H461_ApplicationDisplay::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  if (HasOptionalField(e_language))
    strm << setw(indent+11) << "language = " << setprecision(indent) << m_language << '\n';
  strm << setw(indent+10) << "display = " << setprecision(indent) << m_display << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H461_ApplicationDisplay::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H461_ApplicationDisplay), PInvalidCast);
#endif
  const H461_ApplicationDisplay & other = (const H461_ApplicationDisplay &)obj;

  Comparison result;

  if ((result = m_language.Compare(other.m_language)) != EqualTo)
    return result;
  if ((result = m_display.Compare(other.m_display)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H461_ApplicationDisplay::GetDataLength() const
{
  PINDEX length = 0;
  if (HasOptionalField(e_language))
    length += m_language.GetObjectLength();
  length += m_display.GetObjectLength();
  return length;
}


PBoolean H461_ApplicationDisplay::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (HasOptionalField(e_language) && !m_language.Decode(strm))
    return FALSE;
  if (!m_display.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H461_ApplicationDisplay::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  if (HasOptionalField(e_language))
    m_language.Encode(strm);
  m_display.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H461_ApplicationDisplay::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ApplicationDisplay::Class()), PInvalidCast);
#endif
  return new H461_ApplicationDisplay(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H461_ApplicationState[]={
      {"available",0}
     ,{"unavailable",1}
     ,{"inuse",2}
     ,{"associated",3}
     ,{"invokeFail",4}
};
#endif
//
// ApplicationState
//

H461_ApplicationState::H461_ApplicationState(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 5, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H461_ApplicationState,5
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationState::operator H461_InvokeFailReason &() const
#else
H461_ApplicationState::operator H461_InvokeFailReason &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_InvokeFailReason), PInvalidCast);
#endif
  return *(H461_InvokeFailReason *)choice;
}


H461_ApplicationState::operator const H461_InvokeFailReason &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_InvokeFailReason), PInvalidCast);
#endif
  return *(H461_InvokeFailReason *)choice;
}


PBoolean H461_ApplicationState::CreateObject()
{
  switch (tag) {
    case e_available :
    case e_unavailable :
    case e_inuse :
    case e_associated :
      choice = new PASN_Null();
      return TRUE;
    case e_invokeFail :
      choice = new H461_InvokeFailReason();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H461_ApplicationState::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ApplicationState::Class()), PInvalidCast);
#endif
  return new H461_ApplicationState(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H461_InvokeFailReason[]={
      {"unavailable",0}
     ,{"inuse",1}
     ,{"declined",2}
     ,{"h2250Error",3}
};
#endif
//
// InvokeFailReason
//

H461_InvokeFailReason::H461_InvokeFailReason(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H461_InvokeFailReason,4
#endif
)
{
}


PBoolean H461_InvokeFailReason::CreateObject()
{
  choice = (tag <= e_h2250Error) ? new PASN_Null() : NULL;
  return choice != NULL;
}


PObject * H461_InvokeFailReason::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_InvokeFailReason::Class()), PInvalidCast);
#endif
  return new H461_InvokeFailReason(*this);
}


//
// Application
//

H461_Application::H461_Application(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H461_Application::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "applicationId = " << setprecision(indent) << m_applicationId << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H461_Application::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H461_Application), PInvalidCast);
#endif
  const H461_Application & other = (const H461_Application &)obj;

  Comparison result;

  if ((result = m_applicationId.Compare(other.m_applicationId)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H461_Application::GetDataLength() const
{
  PINDEX length = 0;
  length += m_applicationId.GetObjectLength();
  return length;
}


PBoolean H461_Application::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_applicationId.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H461_Application::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_applicationId.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H461_Application::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_Application::Class()), PInvalidCast);
#endif
  return new H461_Application(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H461_ApplicationInvokeRequest[]={
      {"applicationId",0}
};
#endif
//
// ApplicationInvokeRequest
//

H461_ApplicationInvokeRequest::H461_ApplicationInvokeRequest(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 1, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H461_ApplicationInvokeRequest,1
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationInvokeRequest::operator H225_GenericIdentifier &() const
#else
H461_ApplicationInvokeRequest::operator H225_GenericIdentifier &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_GenericIdentifier), PInvalidCast);
#endif
  return *(H225_GenericIdentifier *)choice;
}


H461_ApplicationInvokeRequest::operator const H225_GenericIdentifier &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_GenericIdentifier), PInvalidCast);
#endif
  return *(H225_GenericIdentifier *)choice;
}


PBoolean H461_ApplicationInvokeRequest::CreateObject()
{
  switch (tag) {
    case e_applicationId :
      choice = new H225_GenericIdentifier();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H461_ApplicationInvokeRequest::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ApplicationInvokeRequest::Class()), PInvalidCast);
#endif
  return new H461_ApplicationInvokeRequest(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H461_ApplicationInvokeResponse[]={
      {"approved",0}
     ,{"declined",1}
};
#endif
//
// ApplicationInvokeResponse
//

H461_ApplicationInvokeResponse::H461_ApplicationInvokeResponse(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 2, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H461_ApplicationInvokeResponse,2
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationInvokeResponse::operator H461_ApplicationInvoke &() const
#else
H461_ApplicationInvokeResponse::operator H461_ApplicationInvoke &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ApplicationInvoke), PInvalidCast);
#endif
  return *(H461_ApplicationInvoke *)choice;
}


H461_ApplicationInvokeResponse::operator const H461_ApplicationInvoke &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_ApplicationInvoke), PInvalidCast);
#endif
  return *(H461_ApplicationInvoke *)choice;
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H461_ApplicationInvokeResponse::operator H461_InvokeFailReason &() const
#else
H461_ApplicationInvokeResponse::operator H461_InvokeFailReason &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_InvokeFailReason), PInvalidCast);
#endif
  return *(H461_InvokeFailReason *)choice;
}


H461_ApplicationInvokeResponse::operator const H461_InvokeFailReason &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H461_InvokeFailReason), PInvalidCast);
#endif
  return *(H461_InvokeFailReason *)choice;
}


PBoolean H461_ApplicationInvokeResponse::CreateObject()
{
  switch (tag) {
    case e_approved :
      choice = new H461_ApplicationInvoke();
      return TRUE;
    case e_declined :
      choice = new H461_InvokeFailReason();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H461_ApplicationInvokeResponse::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ApplicationInvokeResponse::Class()), PInvalidCast);
#endif
  return new H461_ApplicationInvokeResponse(*this);
}


//
// ApplicationStart
//

H461_ApplicationStart::H461_ApplicationStart(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H461_ApplicationStart::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "applicationId = " << setprecision(indent) << m_applicationId << '\n';
  strm << setw(indent+14) << "invokeToken = " << setprecision(indent) << m_invokeToken << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H461_ApplicationStart::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H461_ApplicationStart), PInvalidCast);
#endif
  const H461_ApplicationStart & other = (const H461_ApplicationStart &)obj;

  Comparison result;

  if ((result = m_applicationId.Compare(other.m_applicationId)) != EqualTo)
    return result;
  if ((result = m_invokeToken.Compare(other.m_invokeToken)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H461_ApplicationStart::GetDataLength() const
{
  PINDEX length = 0;
  length += m_applicationId.GetObjectLength();
  length += m_invokeToken.GetObjectLength();
  return length;
}


PBoolean H461_ApplicationStart::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_applicationId.Decode(strm))
    return FALSE;
  if (!m_invokeToken.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H461_ApplicationStart::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_applicationId.Encode(strm);
  m_invokeToken.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H461_ApplicationStart::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ApplicationStart::Class()), PInvalidCast);
#endif
  return new H461_ApplicationStart(*this);
}


//
// ArrayOf_ApplicationStatus
//

H461_ArrayOf_ApplicationStatus::H461_ArrayOf_ApplicationStatus(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H461_ArrayOf_ApplicationStatus::CreateObject() const
{
  return new H461_ApplicationStatus;
}


H461_ApplicationStatus & H461_ArrayOf_ApplicationStatus::operator[](PINDEX i) const
{
  return (H461_ApplicationStatus &)array[i];
}


PObject * H461_ArrayOf_ApplicationStatus::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ArrayOf_ApplicationStatus::Class()), PInvalidCast);
#endif
  return new H461_ArrayOf_ApplicationStatus(*this);
}


//
// ArrayOf_ApplicationAvailable
//

H461_ArrayOf_ApplicationAvailable::H461_ArrayOf_ApplicationAvailable(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H461_ArrayOf_ApplicationAvailable::CreateObject() const
{
  return new H461_ApplicationAvailable;
}


H461_ApplicationAvailable & H461_ArrayOf_ApplicationAvailable::operator[](PINDEX i) const
{
  return (H461_ApplicationAvailable &)array[i];
}


PObject * H461_ArrayOf_ApplicationAvailable::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ArrayOf_ApplicationAvailable::Class()), PInvalidCast);
#endif
  return new H461_ArrayOf_ApplicationAvailable(*this);
}


//
// ArrayOf_ApplicationStart
//

H461_ArrayOf_ApplicationStart::H461_ArrayOf_ApplicationStart(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H461_ArrayOf_ApplicationStart::CreateObject() const
{
  return new H461_ApplicationStart;
}


H461_ApplicationStart & H461_ArrayOf_ApplicationStart::operator[](PINDEX i) const
{
  return (H461_ApplicationStart &)array[i];
}


PObject * H461_ArrayOf_ApplicationStart::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ArrayOf_ApplicationStart::Class()), PInvalidCast);
#endif
  return new H461_ArrayOf_ApplicationStart(*this);
}


//
// ArrayOf_Application
//

H461_ArrayOf_Application::H461_ArrayOf_Application(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H461_ArrayOf_Application::CreateObject() const
{
  return new H461_Application;
}


H461_Application & H461_ArrayOf_Application::operator[](PINDEX i) const
{
  return (H461_Application &)array[i];
}


PObject * H461_ArrayOf_Application::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ArrayOf_Application::Class()), PInvalidCast);
#endif
  return new H461_ArrayOf_Application(*this);
}


//
// ArrayOf_ApplicationDisplay
//

H461_ArrayOf_ApplicationDisplay::H461_ArrayOf_ApplicationDisplay(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H461_ArrayOf_ApplicationDisplay::CreateObject() const
{
  return new H461_ApplicationDisplay;
}


H461_ApplicationDisplay & H461_ArrayOf_ApplicationDisplay::operator[](PINDEX i) const
{
  return (H461_ApplicationDisplay &)array[i];
}


PObject * H461_ArrayOf_ApplicationDisplay::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ArrayOf_ApplicationDisplay::Class()), PInvalidCast);
#endif
  return new H461_ArrayOf_ApplicationDisplay(*this);
}


//
// ArrayOf_AliasAddress
//

H461_ArrayOf_AliasAddress::H461_ArrayOf_AliasAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H461_ArrayOf_AliasAddress::CreateObject() const
{
  return new H225_AliasAddress;
}


H225_AliasAddress & H461_ArrayOf_AliasAddress::operator[](PINDEX i) const
{
  return (H225_AliasAddress &)array[i];
}


PObject * H461_ArrayOf_AliasAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ArrayOf_AliasAddress::Class()), PInvalidCast);
#endif
  return new H461_ArrayOf_AliasAddress(*this);
}


//
// ASSETMessage
//

H461_ASSETMessage::H461_ASSETMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 2, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H461_ASSETMessage::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+14) << "application = " << setprecision(indent) << m_application << '\n';
  if (HasOptionalField(e_associateToken))
    strm << setw(indent+17) << "associateToken = " << setprecision(indent) << m_associateToken << '\n';
  if (HasOptionalField(e_callIdentifier))
    strm << setw(indent+17) << "callIdentifier = " << setprecision(indent) << m_callIdentifier << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H461_ASSETMessage::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H461_ASSETMessage), PInvalidCast);
#endif
  const H461_ASSETMessage & other = (const H461_ASSETMessage &)obj;

  Comparison result;

  if ((result = m_application.Compare(other.m_application)) != EqualTo)
    return result;
  if ((result = m_associateToken.Compare(other.m_associateToken)) != EqualTo)
    return result;
  if ((result = m_callIdentifier.Compare(other.m_callIdentifier)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H461_ASSETMessage::GetDataLength() const
{
  PINDEX length = 0;
  length += m_application.GetObjectLength();
  if (HasOptionalField(e_associateToken))
    length += m_associateToken.GetObjectLength();
  if (HasOptionalField(e_callIdentifier))
    length += m_callIdentifier.GetObjectLength();
  return length;
}


PBoolean H461_ASSETMessage::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_application.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_associateToken) && !m_associateToken.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_callIdentifier) && !m_callIdentifier.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H461_ASSETMessage::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_application.Encode(strm);
  if (HasOptionalField(e_associateToken))
    m_associateToken.Encode(strm);
  if (HasOptionalField(e_callIdentifier))
    m_callIdentifier.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H461_ASSETMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ASSETMessage::Class()), PInvalidCast);
#endif
  return new H461_ASSETMessage(*this);
}


//
// ApplicationStatus
//

H461_ApplicationStatus::H461_ApplicationStatus(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H461_ApplicationStatus::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "applicationId = " << setprecision(indent) << m_applicationId << '\n';
  if (HasOptionalField(e_display))
    strm << setw(indent+10) << "display = " << setprecision(indent) << m_display << '\n';
  if (HasOptionalField(e_avatar))
    strm << setw(indent+9) << "avatar = " << setprecision(indent) << m_avatar << '\n';
  if (HasOptionalField(e_state))
    strm << setw(indent+8) << "state = " << setprecision(indent) << m_state << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H461_ApplicationStatus::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H461_ApplicationStatus), PInvalidCast);
#endif
  const H461_ApplicationStatus & other = (const H461_ApplicationStatus &)obj;

  Comparison result;

  if ((result = m_applicationId.Compare(other.m_applicationId)) != EqualTo)
    return result;
  if ((result = m_display.Compare(other.m_display)) != EqualTo)
    return result;
  if ((result = m_avatar.Compare(other.m_avatar)) != EqualTo)
    return result;
  if ((result = m_state.Compare(other.m_state)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H461_ApplicationStatus::GetDataLength() const
{
  PINDEX length = 0;
  length += m_applicationId.GetObjectLength();
  if (HasOptionalField(e_display))
    length += m_display.GetObjectLength();
  if (HasOptionalField(e_avatar))
    length += m_avatar.GetObjectLength();
  if (HasOptionalField(e_state))
    length += m_state.GetObjectLength();
  return length;
}


PBoolean H461_ApplicationStatus::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_applicationId.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_display) && !m_display.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_avatar) && !m_avatar.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_state) && !m_state.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H461_ApplicationStatus::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_applicationId.Encode(strm);
  if (HasOptionalField(e_display))
    m_display.Encode(strm);
  if (HasOptionalField(e_avatar))
    m_avatar.Encode(strm);
  if (HasOptionalField(e_state))
    m_state.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H461_ApplicationStatus::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ApplicationStatus::Class()), PInvalidCast);
#endif
  return new H461_ApplicationStatus(*this);
}


//
// ApplicationAvailable
//

H461_ApplicationAvailable::H461_ApplicationAvailable(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H461_ApplicationAvailable::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "applicationId = " << setprecision(indent) << m_applicationId << '\n';
  strm << setw(indent+15) << "aliasAddress = " << setprecision(indent) << m_aliasAddress << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H461_ApplicationAvailable::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H461_ApplicationAvailable), PInvalidCast);
#endif
  const H461_ApplicationAvailable & other = (const H461_ApplicationAvailable &)obj;

  Comparison result;

  if ((result = m_applicationId.Compare(other.m_applicationId)) != EqualTo)
    return result;
  if ((result = m_aliasAddress.Compare(other.m_aliasAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H461_ApplicationAvailable::GetDataLength() const
{
  PINDEX length = 0;
  length += m_applicationId.GetObjectLength();
  length += m_aliasAddress.GetObjectLength();
  return length;
}


PBoolean H461_ApplicationAvailable::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_applicationId.Decode(strm))
    return FALSE;
  if (!m_aliasAddress.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H461_ApplicationAvailable::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_applicationId.Encode(strm);
  m_aliasAddress.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H461_ApplicationAvailable::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ApplicationAvailable::Class()), PInvalidCast);
#endif
  return new H461_ApplicationAvailable(*this);
}


//
// ApplicationInvoke
//

H461_ApplicationInvoke::H461_ApplicationInvoke(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H461_ApplicationInvoke::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+16) << "applicationId = " << setprecision(indent) << m_applicationId << '\n';
  strm << setw(indent+14) << "invokeToken = " << setprecision(indent) << m_invokeToken << '\n';
  strm << setw(indent+15) << "aliasAddress = " << setprecision(indent) << m_aliasAddress << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H461_ApplicationInvoke::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H461_ApplicationInvoke), PInvalidCast);
#endif
  const H461_ApplicationInvoke & other = (const H461_ApplicationInvoke &)obj;

  Comparison result;

  if ((result = m_applicationId.Compare(other.m_applicationId)) != EqualTo)
    return result;
  if ((result = m_invokeToken.Compare(other.m_invokeToken)) != EqualTo)
    return result;
  if ((result = m_aliasAddress.Compare(other.m_aliasAddress)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H461_ApplicationInvoke::GetDataLength() const
{
  PINDEX length = 0;
  length += m_applicationId.GetObjectLength();
  length += m_invokeToken.GetObjectLength();
  length += m_aliasAddress.GetObjectLength();
  return length;
}


PBoolean H461_ApplicationInvoke::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_applicationId.Decode(strm))
    return FALSE;
  if (!m_invokeToken.Decode(strm))
    return FALSE;
  if (!m_aliasAddress.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H461_ApplicationInvoke::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_applicationId.Encode(strm);
  m_invokeToken.Encode(strm);
  m_aliasAddress.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H461_ApplicationInvoke::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H461_ApplicationInvoke::Class()), PInvalidCast);
#endif
  return new H461_ApplicationInvoke(*this);
}


#endif // if ! H323_DISABLE_H461


// End of h4610.cxx
